package pkgman

import (
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"gopkg.in/yaml.v3"
)

const PkgFile = "flare.yaml"

type Type string

const (
	TypeModule Type = "module"
	TypeCLI    Type = "cli"
	TypeWeb    Type = "web"
)

type PackageManager struct {
	PackageName   string         `yaml:"packageName"`
	PackageType   Type           `yaml:"type"`
	PackageConfig map[string]any `yaml:"config"`

	Packages []*Package `yaml:"packages"`

	root        string
	packageFile string
}

func New(root string) (*PackageManager, error) {
	var m PackageManager
	m.root = filepath.Clean(root)
	m.packageFile = filepath.Join(m.root, PkgFile)
	m.PackageConfig = make(map[string]any)

	f, err := os.Open(m.packageFile)
	if err == nil {
		defer f.Close()

		data, err := io.ReadAll(f)
		if err != nil {
			return nil, err
		}

		if err := yaml.Unmarshal(data, &m); err != nil {
			return nil, err
		}

		for i, pkg := range m.Packages {
			m.Packages[i], err = m.parseUrl(pkg.Url)
			m.Packages[i].Version = pkg.Version
			if err != nil {
				return nil, err
			}
		}
	}

	return &m, nil
}

// Add adds a package to pkg.yaml
func (pm *PackageManager) Add(packageUrl string) error {
	fmt.Println("ℹ️ Installing package...")
	pkg, err := pm.parseUrl(packageUrl)
	if err != nil {
		return err
	}

	for _, pack := range pm.Packages {
		if pack.Author == pkg.Author && pack.Package == pkg.Package {
			return fmt.Errorf("Package already exists")
		}
	}

	if err := pm.installPackage(pkg); err != nil {
		return err
	}

	pm.Packages = append(pm.Packages, pkg)

	return pm.save()
}

// Remove removes a package from pkg.yaml
func (pm *PackageManager) Remove(packageUrl string) error {
	pkg, err := pm.parseUrl(packageUrl)
	if err != nil {
		return err
	}

	for i, pack := range pm.Packages {
		if pack.Author == pkg.Author && pack.Package == pkg.Package {
			otherUsing := pm.isOtherPackageUsing(pack)
			if otherUsing {
				return nil
			}

			if err := pm.deletePackage(pack); err != nil {
				return err
			}
			pm.Packages = slices.Delete(pm.Packages, i, i+1)
			return pm.save()
		}
	}

	return fmt.Errorf("package not found")
}

// parseUrl parses a package URL and returns a Package struct
func (pm *PackageManager) parseUrl(packageUrl string) (*Package, error) {
	// Extract version
	version := "latest"
	at := strings.LastIndex(packageUrl, "@")
	if at != -1 {
		version = packageUrl[at+1:]
		packageUrl = packageUrl[:at]
	}

	// Validate scheme
	if !strings.HasPrefix(packageUrl, "https://") && !strings.HasPrefix(packageUrl, "git@") {
		return nil, errors.New("invalid package URL")
	}

	// Trim prefixes and suffix
	trimmed := strings.TrimPrefix(packageUrl, "git@")
	trimmed = strings.TrimPrefix(trimmed, "https://")
	trimmed = strings.TrimSuffix(trimmed, ".git")

	// Extract author/repo
	parts := strings.Split(strings.Trim(trimmed, "/"), "/")
	if len(parts) < 2 {
		return nil, errors.New("invalid repository format")
	}
	author := parts[len(parts)-2]
	pkgName := parts[len(parts)-1]

	return &Package{
		Url:     packageUrl,
		Author:  author,
		Package: pkgName,
		Version: version,
	}, nil
}

// save saves the package manager state to pkg.yaml
func (pm *PackageManager) save() error {
	if pm.PackageName == "" {
		pm.PackageName = filepath.Base(pm.root)
	}

	b, err := yaml.Marshal(pm)
	if err != nil {
		return err
	}

	var before = []byte("# Generated by Flare Package Manager\n# Manual: https://flare.mrtn.vip/docs/package-manager\n")

	if err := os.WriteFile(pm.packageFile, append(before, b...), os.ModePerm); err != nil {
		return err
	}

	gitignorePath := filepath.Join(pm.root, ".gitignore")
	if _, err := os.Stat(gitignorePath); os.IsNotExist(err) {
		gitignoreContent := "# Ignore Flare directories\n.flare\n.flmod\n.flcache\n"
		if err := os.WriteFile(gitignorePath, []byte(gitignoreContent), os.ModePerm); err != nil {
			return err
		}
	} else {
		data, err := os.ReadFile(gitignorePath)
		if err != nil {
			return err
		}

		content := string(data)
		dirs := []string{"# Ignore Flare directories", ".flare", ".flmod", ".flcache"}
		for _, dir := range dirs {
			if !strings.Contains(content, dir) {
				content += "\n" + dir
			}
		}

		if err := os.WriteFile(gitignorePath, []byte(content), os.ModePerm); err != nil {
			return err
		}
	}

	return nil
}

func (pm *PackageManager) Save() error {
	return pm.save()
}

func (pm *PackageManager) Download() error {
	fmt.Println("ℹ️ Downloading packages...")
	for _, pkg := range pm.Packages {
		if err := pm.installPackage(pkg); err != nil {
			return err
		}
	}
	return nil
}
